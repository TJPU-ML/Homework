import numpy as np
import math
#用到的函数
def xhat_i(i,X):
	return np.vstack((X[i-1,0:4].T,np.mat('1')))#返回x尖   大小：5*1的矩阵

def f(m,β,X):#要求极小值的“损失函数”，返回函数值（标量）参数 ：m 训练集样本数量  β ：参数(w;b)    X：训练集    大小：5 * m的矩阵
    sum = 0.0
    for i in range(0,m):
        sum = sum + math.log(1+math.exp(β.T*xhat_i(i,X)) ) - X[i,4]*(β.T*xhat_i(i,X))   
    return sum[0,0]

def df(m,β,X):    #返回在β处的梯度   返回一个5*1的新β
    sum = 0.0 
    for i in range(0,m):
        sum = sum + xhat_i(i,X)*(X[i,4]-math.exp(β.T*xhat_i(i,X))/(1+math.exp(β.T*xhat_i(i,X))))
    return (-1)*sum

def TEST(m,β,T):  #根据得到的参数，在测试集上运行，得出正确率  m:测试集样本数   预测为真实标记的概率大于90%，就认为预测正确
    sum = 0.0
    for i in range(0,m):
        if T[i,4] == 1:
            if 1-1.0/(1+math.exp(β.T*xhat_i(i,T)))>0.9:
                sum = sum +1
        else:
            if 1.0/(1+math.exp(β.T*xhat_i(i,T))) >0.9:
                sum = sum +1
    print('正确率：')
    print(sum/m)

#几个常量
DATA = np.matrix('''
5.1 3.5 1.4 0.2 1;
4.9 3.0 1.4 0.2 1;
4.7 3.2 1.3 0.2 1;
4.6 3.1 1.5 0.2 1;
5.0 3.6 1.4 0.2 1;
5.4 3.9 1.7 0.4 1;
4.6 3.4 1.4 0.3 1;
5.0 3.4 1.5 0.2 1;
4.4 2.9 1.4 0.2 1;
4.9 3.1 1.5 0.1 1;
5.4 3.7 1.5 0.2 1;
4.8 3.4 1.6 0.2 1;
4.8 3.0 1.4 0.1 1;
4.3 3.0 1.1 0.1 1;
5.8 4.0 1.2 0.2 1;
5.7 4.4 1.5 0.4 1;
5.4 3.9 1.3 0.4 1;
5.1 3.5 1.4 0.3 1;
5.7 3.8 1.7 0.3 1;
5.1 3.8 1.5 0.3 1;
5.4 3.4 1.7 0.2 1;
5.1 3.7 1.5 0.4 1;
4.6 3.6 1.0 0.2 1;
5.1 3.3 1.7 0.5 1;
4.8 3.4 1.9 0.2 1;
5.0 3.0 1.6 0.2 1;
5.0 3.4 1.6 0.4 1;
5.2 3.5 1.5 0.2 1;
5.2 3.4 1.4 0.2 1;
4.7 3.2 1.6 0.2 1;
4.8 3.1 1.6 0.2 1;
5.4 3.4 1.5 0.4 1;
5.2 4.1 1.5 0.1 1;
5.5 4.2 1.4 0.2 1;
4.9 3.1 1.5 0.2 1;
5.0 3.2 1.2 0.2 1;
5.5 3.5 1.3 0.2 1;
4.9 3.6 1.4 0.1 1;
4.4 3.0 1.3 0.2 1;
5.1 3.4 1.5 0.2 1;
5.0 3.5 1.3 0.3 1;
4.5 2.3 1.3 0.3 1;
4.4 3.2 1.3 0.2 1;
5.0 3.5 1.6 0.6 1;
5.1 3.8 1.9 0.4 1;
4.8 3.0 1.4 0.3 1;
5.1 3.8 1.6 0.2 1;
4.6 3.2 1.4 0.2 1;
5.3 3.7 1.5 0.2 1;
5.0 3.3 1.4 0.2 1;
7.0 3.2 4.7 1.4 0;
6.4 3.2 4.5 1.5 0;
6.9 3.1 4.9 1.5 0;
5.5 2.3 4.0 1.3 0;
6.5 2.8 4.6 1.5 0;
5.7 2.8 4.5 1.3 0;
6.3 3.3 4.7 1.6 0;
4.9 2.4 3.3 1.0 0;
6.6 2.9 4.6 1.3 0;
5.2 2.7 3.9 1.4 0;
5.0 2.0 3.5 1.0 0;
5.9 3.0 4.2 1.5 0;
6.0 2.2 4.0 1.0 0;
6.1 2.9 4.7 1.4 0;
5.6 2.9 3.6 1.3 0;
6.7 3.1 4.4 1.4 0;
5.6 3.0 4.5 1.5 0;
5.8 2.7 4.1 1.0 0;
6.2 2.2 4.5 1.5 0;
5.6 2.5 3.9 1.1 0;
5.9 3.2 4.8 1.8 0;
6.1 2.8 4.0 1.3 0;
6.3 2.5 4.9 1.5 0;
6.1 2.8 4.7 1.2 0;
6.4 2.9 4.3 1.3 0;
6.6 3.0 4.4 1.4 0;
6.8 2.8 4.8 1.4 0;
6.7 3.0 5.0 1.7 0;
6.0 2.9 4.5 1.5 0;
5.7 2.6 3.5 1.0 0;
5.5 2.4 3.8 1.1 0;
5.5 2.4 3.7 1.0 0;
5.8 2.7 3.9 1.2 0;
6.0 2.7 5.1 1.6 0;
5.4 3.0 4.5 1.5 0;
6.0 3.4 4.5 1.6 0;
6.7 3.1 4.7 1.5 0;
6.3 2.3 4.4 1.3 0;
5.6 3.0 4.1 1.3 0;
5.5 2.5 4.0 1.3 0;
5.5 2.6 4.4 1.2 0;
6.1 3.0 4.6 1.4 0;
5.8 2.6 4.0 1.2 0;
5.0 2.3 3.3 1.0 0;
5.6 2.7 4.2 1.3 0;
5.7 3.0 4.2 1.2 0;
5.7 2.9 4.2 1.3 0;
6.2 2.9 4.3 1.3 0;
5.1 2.5 3.0 1.1 0;
5.7 2.8 4.1 1.3 0''')
step = 0.005 #步长
time = 500 # 训练次数


#流程：
print('第一次实验损失函数：  训练集：测试集=1：1')
S1 = np.vstack((DATA[0:25],DATA[50:75]))
T1= np.vstack((DATA[25:50],DATA[75:100]))
β1= np.mat('0;0;0;0;0')
for i in range(0,time):
    print(f(50,β1,S1)) #输出损失函数
    β1 = β1 - step*df(50,β1,S1)


print('第二次实验损失函数： 训练集：测试集=7：3')
S2= np.vstack((DATA[0:35],DATA[50:85]))
T2 = np.vstack((DATA[35:50],DATA[85:100]))
β2= np.mat('0;0;0;0;0')
for i in range(0,time):
    print(f(70,β2,S2)) #输出损失函数
    β2 = β2 - step*df(70,β2,S2)


print('第三次实验损失函数： 训练集：测试集=9：1')
S3 = np.vstack((DATA[0:45],DATA[50:95]))
T3 = np.vstack((DATA[45:50],DATA[95:100]))
β3 = np.mat('0;0;0;0;0')
for i in range(0,time):
    print(f(70,β3,S3)) #输出损失函数
    β3 = β3 - step*df(90,β3,S3)
print('三次实验的正确率：')
TEST(50,β1,T1)
TEST(30,β2,T2)
TEST(10,β3,T3)

input()


